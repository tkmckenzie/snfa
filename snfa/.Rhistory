N.fit = nrow(X.fit)
if ((ncol(X.eval) == ncol(X.constrained)) & (ncol(X.constrained) == ncol(X.fit)) & (ncol(X.fit) == ncol(X.bounded))){
k = ncol(X.eval)
} else{
stop("X.eval, X.constrained, and X.fit must have same number of columns.")
}
#Combine X.fit and X.constrained
#First eliminate observations in X.constrained that appear in X.fit
duplicated.rows = prodlim::row.match(as.data.frame(X.fit), as.data.frame(X.constrained))
duplicated.rows = duplicated.rows[!is.na(duplicated.rows)]
if (length(duplicated.rows) == 0){
X.fit = rbind(X.fit, X.constrained)
} else{
X.fit = rbind(X.fit, X.constrained[-duplicated.rows,,drop = FALSE])
}
N.fit.new = nrow(X.fit)
#Rule of thumb for multivariate:
if (any(is.na(H.inv))){
H.inv = H.inv.select(X.bounded)
}
#Bounding constraints:
# K = apply(X.eval, 1, function(X.0) apply(X.constrained, 1, function(X.i) kernel.func(X.0, X.i, H.inv)))
K = apply(X.eval, 1, function(X.0) apply(X.bounded, 1, function(X.i) kernel.func(X.0, X.i, H.inv)))
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/load_unexported.R', echo=TRUE)
#Bounding constraints:
# K = apply(X.eval, 1, function(X.0) apply(X.constrained, 1, function(X.i) kernel.func(X.0, X.i, H.inv)))
K = apply(X.eval, 1, function(X.0) apply(X.bounded, 1, function(X.i) kernel.func(X.0, X.i, H.inv)))
A = K / rowSums(K)
bounding.constraints = t(t(A) * y.eval)
#K[i,j] = K(X[i,], X.fit[j,])
K = apply(X.fit, 1, function(X.0) apply(X.eval, 1, function(X.i) kernel.func(X.0, X.i, H.inv)))
#A[i,j] = A(X[i,], X[j,])
A = t(K) / colSums(K)
A.y = t(t(A) * y.eval)
#K.grad[i,j,k] = dK(X[i,], X[j,]) / dX_k
K.grad = aperm(abind::abind(lapply(1:N.eval, function(index.0) kernel.grad.mult(index.0, H.inv, X.eval, X.fit, K)), along = 3), c(3, 2, 1))
#A.grad[i,j,k] = dA(X[i,], X[j,]) / dX_k
K.sum = colSums(K)
K.grad.sum = apply(K.grad, c(2, 3), sum)
A.grad = aperm(abind::abind(lapply(1:N.eval, function(j) t((K.grad[j,,] * K.sum - K.grad.sum * K[j,]) / (K.sum)^2)), along = 3), c(2, 3, 1))
# monotonicity.constraints = t(t(apply(A.grad, 1:2, sum)) * y)
monotonicity.constraints = Reduce(rbind, lapply(1:k, function(j) t(t(A.grad[,,j]) * y.eval)))
monotonicity.constraints
constraints = rbind(bounding.constraints, monotonicity.constraints)
log.scaling.factor = floor(-mean(log(abs(constraints), base = 10)))
if (log.scaling.factor < 0){
log.scaling.factor = 0
}
scaling.factor = 10^log.scaling.factor
p.hat = try(quadprog::solve.QP(Dmat = diag(N.eval),
dvec = rep(1, N.eval),
Amat = scaling.factor * t(constraints),
bvec = scaling.factor * c(y.bounded, rep(0, (N.fit.new) * k)),
meq = 0)$solution,
silent = TRUE)
# print(mode(p.hat))
y.fit = A.y %*% p.hat
gradient.fit = sapply(1:k, function(d) t(t(A.grad[,,d]) * y.eval) %*% p.hat)
gradient.fit
concavity.constraints = t(Reduce(cbind, lapply(1:(N.fit.new), function(i) concavity.matrix(i, X.fit, y.eval, A, A.grad))))
trivial.constraints = seq(1, (N.fit.new)^2, by = (N.fit.new) + 1)
if (length(trivial.constraints) > 0) concavity.constraints = concavity.constraints[-trivial.constraints,] #Remove 0 * p >= 0 constraints
constraints = rbind(bounding.constraints, monotonicity.constraints, concavity.constraints)
log.scaling.factor = floor(-mean(log(abs(constraints), base = 10)))
if (log.scaling.factor < 0){
log.scaling.factor = 0
}
scaling.factor = 10^log.scaling.factor
p.hat = try(quadprog::solve.QP(Dmat = diag(N.eval),
dvec = rep(1, N.eval),
Amat = scaling.factor * t(constraints),
bvec = scaling.factor * c(y.bounded, rep(0, (N.fit.new) * (N.fit.new + k - 1))),
meq = 0)$solution,
silent = TRUE)
# print(mode(p.hat))
y.fit = A.y %*% p.hat
gradient.fit = sapply(1:k, function(d) t(t(A.grad[,,d]) * y.eval) %*% p.hat)
gradient.fit
scaling.factor = 1
p.hat = try(quadprog::solve.QP(Dmat = diag(N.eval),
dvec = rep(1, N.eval),
Amat = scaling.factor * t(constraints),
bvec = scaling.factor * c(y.bounded, rep(0, (N.fit.new) * (N.fit.new + k - 1))),
meq = 0)$solution,
silent = TRUE)
p.hat
# print(mode(p.hat))
y.fit = A.y %*% p.hat
gradient.fit = sapply(1:k, function(d) t(t(A.grad[,,d]) * y.eval) %*% p.hat)
gradient.fit
example(fit.boudnary)
example(fit.boundary)
rm(list = ls())
data(univariate)
X = as.matrix(univariate$x)
y = univariate$y
X = cbind(2, X)
N.fit = 100
X = cbind(2, X)
library(snfa)
rm(list = ls())
data(univariate)
X = as.matrix(univariate$x)
y = univariate$y
N.fit = 100
X.fit = as.matrix(seq(min(X), max(X), length.out = N.fit))
X = cbind(2, X)
X.fit = cbind(2, X)
#Reflect data for fitting
reflected.data = reflect.data(X, y)
X.eval = reflected.data$X
y.eval = reflected.data$y
#Fit frontiers
frontier.u = fit.boundary(X.eval, y.eval,
X.bounded = X, y.bounded = y,
X.constrained = X.fit,
X.fit = X.fit,
method = "u")
library(snfa)
rm(list = ls())
data(univariate)
X = as.matrix(univariate$x)
y = univariate$y
N.fit = 100
X.fit = as.matrix(seq(min(X), max(X), length.out = N.fit))
X = cbind(2, X)
X.fit = cbind(2, X.fit)
#Reflect data for fitting
reflected.data = reflect.data(X, y)
X.eval = reflected.data$X
y.eval = reflected.data$y
#Fit frontiers
frontier.u = fit.boundary(X.eval, y.eval,
X.bounded = X, y.bounded = y,
X.constrained = X.fit,
X.fit = X.fit,
method = "u")
H.inv = H.inv.select(X)
data(univariate)
X = as.matrix(univariate$x)
y = univariate$y
N.fit = 100
X.fit = as.matrix(seq(min(X), max(X), length.out = N.fit))
H.inv = H.inv.select(X)
H.inv
X = cbind(2, X)
X.fit = cbind(2, X.fit)
H.inv = diag(c(1, H.inv))
#Reflect data for fitting
reflected.data = reflect.data(X, y)
X.eval = reflected.data$X
y.eval = reflected.data$y
#Fit frontiers
frontier.u = fit.boundary(X.eval, y.eval,
X.bounded = X, y.bounded = y,
X.constrained = X.fit,
X.fit = X.fit,
method = "u")
#Fit frontiers
frontier.u = fit.boundary(X.eval, y.eval,
X.bounded = X, y.bounded = y,
X.constrained = X.fit,
X.fit = X.fit,
method = "u",
H.inv = H.inv)
frontier.m = fit.boundary(X.eval, y.eval,
X.bounded = X, y.bounded = y,
X.constrained = X.fit,
X.fit = X.fit,
method = "m",
H.inv = H.inv)
frontier.mc = fit.boundary(X.eval, y.eval,
X.bounded = X, y.bounded = y,
X.constrained = X.fit,
X.fit = X.fit,
method = "mc",
H.inv = H.inv)
#Plot frontier
library(ggplot2)
frontier.df = data.frame(X = rep(X.fit, times = 3),
y = c(frontier.u$y.fit, frontier.m$y.fit, frontier.mc$y.fit),
model = rep(c("u", "m", "mc"), each = N.fit))
frontier.df = data.frame(X = rep(X.fit[,2], times = 3),
y = c(frontier.u$y.fit, frontier.m$y.fit, frontier.mc$y.fit),
model = rep(c("u", "m", "mc"), each = N.fit))
frontier.mc$y.fit
frontier.m$y.fit
X.bounded = X
y.bounded = y
method = "mc"
X.constrained = X.fit
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/load_unexported.R', echo=TRUE)
stopifnot(method %in% c("u", "m", "mc")) #(u)nconstrained, (m)onotonically increasing, (c)oncave
if (any(is.na(X.constrained))){
X.constrained = X.bounded
}
if (any(is.na(X.fit))){
X.fit = X.constrained
}
if (!any(is.na(y.fit.observed)) & (length(y.fit.observed) != nrow(X.fit))){
stop("y.fit.observed must have same number of observations as X.fit.")
}
N.eval = nrow(X.eval)
y.fit.observed = NA
if (!any(is.na(y.fit.observed)) & (length(y.fit.observed) != nrow(X.fit))){
stop("y.fit.observed must have same number of observations as X.fit.")
}
N.eval = nrow(X.eval)
N.bounded = nrow(X.bounded)
N.constrained = nrow(X.constrained)
N.fit = nrow(X.fit)
if ((ncol(X.eval) == ncol(X.constrained)) & (ncol(X.constrained) == ncol(X.fit)) & (ncol(X.fit) == ncol(X.bounded))){
k = ncol(X.eval)
} else{
stop("X.eval, X.constrained, and X.fit must have same number of columns.")
}
#Combine X.fit and X.constrained
#First eliminate observations in X.constrained that appear in X.fit
duplicated.rows = prodlim::row.match(as.data.frame(X.fit), as.data.frame(X.constrained))
duplicated.rows = duplicated.rows[!is.na(duplicated.rows)]
if (length(duplicated.rows) == 0){
X.fit = rbind(X.fit, X.constrained)
} else{
X.fit = rbind(X.fit, X.constrained[-duplicated.rows,,drop = FALSE])
}
N.fit.new = nrow(X.fit)
#Rule of thumb for multivariate:
if (any(is.na(H.inv))){
H.inv = H.inv.select(X.bounded)
}
#Bounding constraints:
# K = apply(X.eval, 1, function(X.0) apply(X.constrained, 1, function(X.i) kernel.func(X.0, X.i, H.inv)))
K = apply(X.eval, 1, function(X.0) apply(X.bounded, 1, function(X.i) kernel.func(X.0, X.i, H.inv)))
A = K / rowSums(K)
bounding.constraints = t(t(A) * y.eval)
#K[i,j] = K(X[i,], X.fit[j,])
K = apply(X.fit, 1, function(X.0) apply(X.eval, 1, function(X.i) kernel.func(X.0, X.i, H.inv)))
#A[i,j] = A(X[i,], X[j,])
A = t(K) / colSums(K)
A.y = t(t(A) * y.eval)
#K.grad[i,j,k] = dK(X[i,], X[j,]) / dX_k
K.grad = aperm(abind::abind(lapply(1:N.eval, function(index.0) kernel.grad.mult(index.0, H.inv, X.eval, X.fit, K)), along = 3), c(3, 2, 1))
#A.grad[i,j,k] = dA(X[i,], X[j,]) / dX_k
K.sum = colSums(K)
K.grad.sum = apply(K.grad, c(2, 3), sum)
A.grad = aperm(abind::abind(lapply(1:N.eval, function(j) t((K.grad[j,,] * K.sum - K.grad.sum * K[j,]) / (K.sum)^2)), along = 3), c(2, 3, 1))
log.scaling.factor = floor(-mean(log(abs(bounding.constraints), base = 10)))
if (log.scaling.factor < 0){
log.scaling.factor = 0
}
scaling.factor = 10^log.scaling.factor
p.hat = try(quadprog::solve.QP(Dmat = diag(N.eval),
dvec = rep(1, N.eval),
Amat = scaling.factor * t(bounding.constraints),
bvec = scaling.factor * y.bounded,
meq = 0)$solution,
silent = TRUE)
# monotonicity.constraints = t(t(apply(A.grad, 1:2, sum)) * y)
monotonicity.constraints = Reduce(rbind, lapply(1:k, function(j) t(t(A.grad[,,j]) * y.eval)))
constraints = rbind(bounding.constraints, monotonicity.constraints)
log.scaling.factor = floor(-mean(log(abs(constraints), base = 10)))
if (log.scaling.factor < 0){
log.scaling.factor = 0
}
scaling.factor = 10^log.scaling.factor
p.hat = try(quadprog::solve.QP(Dmat = diag(N.eval),
dvec = rep(1, N.eval),
Amat = scaling.factor * t(constraints),
bvec = scaling.factor * c(y.bounded, rep(0, (N.fit.new) * k)),
meq = 0)$solution,
silent = TRUE)
p.hat
scaling.factor
scaling.factor = 1
p.hat = try(quadprog::solve.QP(Dmat = diag(N.eval),
dvec = rep(1, N.eval),
Amat = scaling.factor * t(constraints),
bvec = scaling.factor * c(y.bounded, rep(0, (N.fit.new) * k)),
meq = 0)$solution,
silent = TRUE)
concavity.constraints = t(Reduce(cbind, lapply(1:(N.fit.new), function(i) concavity.matrix(i, X.fit, y.eval, A, A.grad))))
trivial.constraints = seq(1, (N.fit.new)^2, by = (N.fit.new) + 1)
if (length(trivial.constraints) > 0) concavity.constraints = concavity.constraints[-trivial.constraints,] #Remove 0 * p >= 0 constraints
constraints = rbind(bounding.constraints, monotonicity.constraints, concavity.constraints)
log.scaling.factor = floor(-mean(log(abs(constraints), base = 10)))
if (log.scaling.factor < 0){
log.scaling.factor = 0
}
scaling.factor = 10^log.scaling.factor
scaling.factor = 1
p.hat = try(quadprog::solve.QP(Dmat = diag(N.eval),
dvec = rep(1, N.eval),
Amat = scaling.factor * t(constraints),
bvec = scaling.factor * c(y.bounded, rep(0, (N.fit.new) * (N.fit.new + k - 1))),
meq = 0)$solution,
silent = TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/reinstall.R', echo=TRUE)
library(snfa)
rm(list = ls())
data(univariate)
X = as.matrix(univariate$x)
y = univariate$y
N.fit = 100
X.fit = as.matrix(seq(min(X), max(X), length.out = N.fit))
H.inv = H.inv.select(X)
X = cbind(2, X)
X.fit = cbind(2, X.fit)
H.inv = diag(c(1, H.inv))
#Reflect data for fitting
reflected.data = reflect.data(X, y)
X.eval = reflected.data$X
y.eval = reflected.data$y
X.bounded = X
y.bounded = y
X.constrained = X.fit
y.fit.observed = NA
method = "mc"
#Fit frontiers
frontier.u = fit.boundary(X.eval, y.eval,
X.bounded = X, y.bounded = y,
X.constrained = X.fit,
X.fit = X.fit,
method = "u",
H.inv = H.inv)
frontier.m = fit.boundary(X.eval, y.eval,
X.bounded = X, y.bounded = y,
X.constrained = X.fit,
X.fit = X.fit,
method = "m",
H.inv = H.inv)
frontier.mc = fit.boundary(X.eval, y.eval,
X.bounded = X, y.bounded = y,
X.constrained = X.fit,
X.fit = X.fit,
method = "mc",
H.inv = H.inv)
#Plot frontier
library(ggplot2)
frontier.df = data.frame(X = rep(X.fit[,2], times = 3),
y = c(frontier.u$y.fit, frontier.m$y.fit, frontier.mc$y.fit),
model = rep(c("u", "m", "mc"), each = N.fit))
ggplot(univariate, aes(X, y)) +
geom_point() +
geom_line(data = frontier.df, aes(color = model))
frontier.df
ggplot(univariate, aes(X, y)) +
geom_point() +
geom_line(data = frontier.df, aes(color = model))
head(frontier.df)
ggplot(univariate, aes(X, y)) +
geom_point()
univariate
head(univariate)
frontier.df = data.frame(x = rep(X.fit[,2], times = 3),
y = c(frontier.u$y.fit, frontier.m$y.fit, frontier.mc$y.fit),
model = rep(c("u", "m", "mc"), each = N.fit))
ggplot(univariate, aes(x, y)) +
geom_point() +
geom_line(data = frontier.df, aes(color = model))
#Plot slopes
slope.df = data.frame(X = rep(X.fit, times = 3),
slope = c(frontier.u$gradient.fit,
frontier.m$gradient.fit,
frontier.mc$gradient.fit),
model = rep(c("u", "m", "mc"), each = N.fit))
ggplot(slope.df, aes(X, slope)) +
geom_line(aes(color = model))
#Plot slopes
slope.df = data.frame(X = rep(X.fit[,2], times = 3),
slope = c(frontier.u$gradient.fit[,2],
frontier.m$gradient.fit[,2],
frontier.mc$gradient.fit[,2]),
model = rep(c("u", "m", "mc"), each = N.fit))
ggplot(slope.df, aes(X, slope)) +
geom_line(aes(color = model))
any(frontier.m$gradient.fit < 0)
frontier.m$gradient.fit
source('C:/Users/Taylor/Dropbox/Research/SNFA/testing/test.R', echo=TRUE)
gradient.fit
frontier.m$gradient.fit
stopifnot(method %in% c("u", "m", "mc")) #(u)nconstrained, (m)onotonically increasing, (c)oncave
if (any(is.na(X.constrained))){
X.constrained = X.bounded
}
if (any(is.na(X.fit))){
X.fit = X.constrained
}
if (!any(is.na(y.fit.observed)) & (length(y.fit.observed) != nrow(X.fit))){
stop("y.fit.observed must have same number of observations as X.fit.")
}
N.eval = nrow(X.eval)
N.bounded = nrow(X.bounded)
N.constrained = nrow(X.constrained)
N.fit = nrow(X.fit)
if ((ncol(X.eval) == ncol(X.constrained)) & (ncol(X.constrained) == ncol(X.fit)) & (ncol(X.fit) == ncol(X.bounded))){
k = ncol(X.eval)
} else{
stop("X.eval, X.constrained, and X.fit must have same number of columns.")
}
#Combine X.fit and X.constrained
#First eliminate observations in X.constrained that appear in X.fit
duplicated.rows = prodlim::row.match(as.data.frame(X.fit), as.data.frame(X.constrained))
duplicated.rows = duplicated.rows[!is.na(duplicated.rows)]
if (length(duplicated.rows) == 0){
X.fit = rbind(X.fit, X.constrained)
} else{
X.fit = rbind(X.fit, X.constrained[-duplicated.rows,,drop = FALSE])
}
N.fit.new = nrow(X.fit)
#Rule of thumb for multivariate:
if (any(is.na(H.inv))){
H.inv = H.inv.select(X.bounded)
}
#Bounding constraints:
# K = apply(X.eval, 1, function(X.0) apply(X.constrained, 1, function(X.i) kernel.func(X.0, X.i, H.inv)))
K = apply(X.eval, 1, function(X.0) apply(X.bounded, 1, function(X.i) kernel.func(X.0, X.i, H.inv)))
A = K / rowSums(K)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/load_unexported.R', echo=TRUE)
#Bounding constraints:
# K = apply(X.eval, 1, function(X.0) apply(X.constrained, 1, function(X.i) kernel.func(X.0, X.i, H.inv)))
K = apply(X.eval, 1, function(X.0) apply(X.bounded, 1, function(X.i) kernel.func(X.0, X.i, H.inv)))
A = K / rowSums(K)
bounding.constraints = t(t(A) * y.eval)
#K[i,j] = K(X[i,], X.fit[j,])
K = apply(X.fit, 1, function(X.0) apply(X.eval, 1, function(X.i) kernel.func(X.0, X.i, H.inv)))
#A[i,j] = A(X[i,], X[j,])
A = t(K) / colSums(K)
A.y = t(t(A) * y.eval)
#K.grad[i,j,k] = dK(X[i,], X[j,]) / dX_k
K.grad = aperm(abind::abind(lapply(1:N.eval, function(index.0) kernel.grad.mult(index.0, H.inv, X.eval, X.fit, K)), along = 3), c(3, 2, 1))
#A.grad[i,j,k] = dA(X[i,], X[j,]) / dX_k
K.sum = colSums(K)
K.grad.sum = apply(K.grad, c(2, 3), sum)
A.grad = aperm(abind::abind(lapply(1:N.eval, function(j) t((K.grad[j,,] * K.sum - K.grad.sum * K[j,]) / (K.sum)^2)), along = 3), c(2, 3, 1))
# monotonicity.constraints = t(t(apply(A.grad, 1:2, sum)) * y)
monotonicity.constraints = Reduce(rbind, lapply(1:k, function(j) t(t(A.grad[,,j]) * y.eval)))
constraints = rbind(bounding.constraints, monotonicity.constraints)
# log.scaling.factor = floor(-mean(log(abs(constraints), base = 10)))
# if (log.scaling.factor < 0){
#   log.scaling.factor = 0
# }
# scaling.factor = 10^log.scaling.factor
scaling.factor = 1
p.hat = try(quadprog::solve.QP(Dmat = diag(N.eval),
dvec = rep(1, N.eval),
Amat = scaling.factor * t(constraints),
bvec = scaling.factor * c(y.bounded, rep(0, (N.fit.new) * k)),
meq = 0)$solution,
silent = TRUE)
p.hat
# print(mode(p.hat))
y.fit = A.y %*% p.hat
gradient.fit = sapply(1:k, function(d) t(t(A.grad[,,d]) * y.eval) %*% p.hat)
gradient.fit
constraints %*% p.hat
constraints %*% p.hat - c(y.bounded, rep(0, (N.fit.new) * k)
)
log.scaling.factor = floor(-mean(log(abs(constraints), base = 10)))
if (log.scaling.factor < 0){
log.scaling.factor = 0
}
scaling.factor = 10^log.scaling.factor
p.hat = try(quadprog::solve.QP(Dmat = diag(N.eval),
dvec = rep(1, N.eval),
Amat = scaling.factor * t(constraints),
bvec = scaling.factor * c(y.bounded, rep(0, (N.fit.new) * k)),
meq = 0)$solution,
silent = TRUE)
p.hat
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/document.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/check.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/document.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/document.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/check.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/document.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/check.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/document.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/check.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/reinstall.R', echo=TRUE)
type(data.frame())
str(data.frame())
str(data.frame()) == "data.frame"
typeof(data.frame()) == "data.frame"
typeof(data.frame())
class(data.frame())
c("a", "b", "c") %in% c("e", "a", "b", "d", "c")
c("a", "b", "c") %in% c("e", "a", "b", "d", "f")
order(c(1, 1, 2, 3), c(3, 4, 5, 6))
order(c(1, 1, 2, 3), c(4, 3, 5, 6))
1 / 3
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/document.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/reinstall.R', echo=TRUE)
library(snfa)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/check.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/document.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/reinstall.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/check.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/document.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/reinstall.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/document.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/reinstall.R', echo=TRUE)
library(snfa)
?technical.efficiency.change
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/document.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/reinstall.R', echo=TRUE)
library(snfa)
?technical.efficiency.change
?prcomp
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/build.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/reinstall.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/reinstall.R', echo=TRUE)
source('C:/Users/Taylor/Dropbox/Research/SNFA/snfa_package/document.R', echo=TRUE)
